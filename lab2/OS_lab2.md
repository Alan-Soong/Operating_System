# 操作系统lab1实验报告
<center><p><font face="黑体" size=7><b>操作系统lab1实验报告</b></font></p></center>
<center><p><font face="楷体" size=4>姓名：宋卓伦，赵雨萱，何立烽&nbsp;&nbsp;&nbsp;&nbsp;学号：2311095，2311100，2311101</font></p></center>
<center><p><font face="楷体" size=4>南开大学计算机学院、密码与网络空间安全学院</font></p></center>
<!-- <br> -->

## 实验名称：物理内存管理

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

---

### 各函数作用及物理内存分配过程分析

程序通过 `default_pmm_manager` 结构体，利用函数指针将具体的内存管理算法（First-Fit）封装起来。物理内存的分配和释放过程主要围绕一个按地址排序的空闲块双向链表 `free_list` 展开。

**各核心函数作用分析如下：**

* **`default_init()`**
    * **作用**: 初始化内存管理器。
    * **描述**: 这是系统启动时调用的第一个函数。它通过调用 `list_init(&free_list)` 创建一个空的双向链表，然后将全局空闲页总数 `nr_free` 设置为0。在这一阶段，内核还不知道具体有哪些物理内存是可用的。

* **`default_init_memmap()`**
    * **作用**: 将一块新发现的、可用的物理内存区域，格式化后加入到空闲链表中。
    * **描述**: 函数接收一个指向 `Page` 结构体的指针 `base` 和连续页的数量 `n`。它首先遍历这 `n` 个页，清除它们的 `flags` 标志位并将引用计数 `ref` 置为0。接着，它将起始页 `base` 的 `property` 字段设置为 `n`，并调用 `SetPageProperty(base)`，以此明确标记这是一个大小为 `n` 的空闲块的“头部”。最后，将 `n` 加到 `nr_free` 上，并通过一个 `while` 循环找到正确的位置，将这个新的空闲块插入到 `free_list` 中，确保整个链表始终按照物理地址从小到大排序。

* **`default_alloc_pages()`**
    * **作用**: 实现 First-Fit 算法的核心，负责查找并分配 `n` 个连续的物理页。
    * **描述**:
        1.  **检查**: 首先进行合法性检查，确保 `n > 0` 且总空闲页数 `nr_free` 足够，否则返回 `NULL`。
        2.  **查找**: 从 `free_list` 的头部开始遍历，寻找**第一个** `property >= n` 的空闲块。一旦找到，立刻用 `break` 停止搜索。
        3.  **分割**: 如果找到的块 `page` 比请求的 `n` 大 (`page->property > n`)，则进行分割。将 `page` 从 `free_list` 中移除，然后计算出剩余部分（从 `page + n` 开始），将其大小（`page->property - n`）记录在新头部，并作为一个新的小空闲块重新插入 `free_list`。
        4.  **更新**: 从 `nr_free` 中减去 `n`，调用 `ClearPageProperty(page)` 清除已分配块的“空闲头部”标志。
        5.  **返回**: 返回指向已分配内存块头部的指针 `page`。

* **`default_free_pages()`**
    * **作用**: 将一块使用完毕的内存归还给系统，并尝试与相邻的空闲块合并。
    * **描述**:
        1.  **标记**: 函数接收要释放的内存块 `base` 和大小 `n`，重置其内部所有页的标志位和引用计数。然后将其标记为一个新的、大小为 `n` 的空闲块。
        2.  **插入**: 将这个新释放的块按地址顺序插入到 `free_list` 中。
        3.  **合并**: 这是防止内存碎片化的关键。它会检查新插入块在链表中的**前一个**和**后一个**空闲块，判断它们在物理地址上是否紧邻。如果紧邻，就将它们合并成一个更大的空闲块，更新 `property` 值，并从链表中删除被“吃掉”的那个块。

* **`default_nr_free_pages()`**
    * **作用**: 查询当前空闲页的总数。
    * **描述**: 直接返回全局变量 `nr_free` 的值。

* **`default_check()`**
    * **作用**: 内置的自检程序，用于验证内存管理算法的正确性。
    * **描述**: 通过一系列预设的分配和释放操作，以及 `assert` 断言，来测试分配、释放、分割和合并等核心逻辑是否按预期工作。

---
#### 你的first fit算法是否有进一步的改进空间？
是的，First-Fit 算法虽然实现简单直观，但其策略本身和实现方式都存在很大的改进空间。我们可以从两方面进行讨论。


#### 一：采用更优秀的分配算法进行替代

**1.缺点：**
First-Fit 算法的核心缺陷在于其简单的查找策略容易导致内存布局的恶化。由于每次分配都固定从链表头部开始搜索，这会使得内存的低地址区域被反复切割，从而产生大量难以再利用的微小内存碎片。与此同时，随着头部碎片的累积，后续需要较大内存的分配请求，将不得不耗费更多时间跳过这些无用的小碎片，导致查找效率降低。

**2. 改进方案（即采用新算法）：**
   针对这些固有缺陷，其“改进空间”主要体现在采用更优越的分配策略来替代它，而这些方法在后面的练习与challenge中都有设计，比如说**练习二**的 **Best-Fit**，**挑战练习**的 **Buddy System**，也可用**Next-Fit**

#### 二：在保持 First-Fit 核心思想不变的前提下进行优化

当前 `default_pmm.c` 的实现是基于一个简单的双向链表，查找第一个足够大的块的时间复杂度是 **O(n)**，其中 n 是空闲块的数量。当空闲块非常多时，这个线性扫描的效率会很低。

一个可行的改进方案是**优化承载空闲块的数据结构**，例如：

**1.使用多级链表/分离适配 (Segregated Lists)**：
  我们可以创建多个空闲链表，每个链表负责一个特定的大小范围（例如，一个链表只存放 1-8 页的块，另一个存放 9-16 页的块，等等）。当请求一个大小为 `k` 的块时，我们只需要在对应大小范围的链表里进行 First-Fit 查找即可。这极大地减少了需要扫描的节点数量，是一种典型的空间换时间优化。

 **2.使用更高级的数据结构**：
  例如，我们可以用**平衡二叉搜索树**或**跳表 (Skip List)** 来组织空闲块（按大小排序）。这些数据结构可以将查找“第一个大于等于 k 的块”这个操作的时间复杂度从 O(n) 优化到 **O(log n)**。虽然这会增加实现的复杂度和插入/删除操作的开销，但在查找密集型的场景下，性能提升将是显著的。


---

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

---

#### 设计与实现过程


**核心逻辑修改**：我们需要对 `best_fit_alloc_pages` 函数进行修改。与 First-Fit 找到第一个满足条件的块就停止不同，Best-Fit 必须遍历整个空闲链表，找到那个能够满足需求（`size >= n`）且尺寸最接近的块。



#### 物理内存的分配与释放

##### 内存分配 (`best_fit_alloc_pages`)

当系统请求分配 `n` 个页时，`best_fit_alloc_pages` 函数执行以下步骤：
1.  **初始化**：与first-fit算法不同，我们定义一个 `best_page` 指针初始化为 `NULL`，用于记录最终找到的最佳空闲块。
2.  **寻找最佳匹配**：使用 `while` 循环**遍历整个** `free_list` 链表，**不会提前 `break`**。在循环中，对每一个空闲块 `p`，进行判断：首先，检查块的大小 `p->property` 是否满足请求 (`>= n`)。如果满足，则进一步判断它是否是“更佳”的选择：即 `best_page` 还是 `NULL`（说明这是第一个找到的可用块），或者当前块 `p` 的大小比已记录的 `best_page` 的大小更小（`p->property < best_page->property`）。如果满足“更佳”条件，则更新 `best_page = p`。初始时我们把best_page的值设置的很大，比如说总空闲页数+1，这样方便第一次·更新
3.  **分配与分割**：循环结束后，`best_page` 指向了最合适的空闲块。后续的逻辑与 First-Fit 相同： 将 `best_page` 从 `free_list` 中移除。如果 `best_page` 的大小严格大于 `n`，则将多余的部分作为一个新的、更小的空闲块重新插入 `free_list`。更新全局空闲页数 `nr_free`，并清除已分配块的 `PG_property` 标志。
4.  **返回结果**：返回 `best_page` 指针。如果遍历完也未找到可用块，则返回 `NULL`。

##### 内存释放 (`best_fit_free_pages`)

内存释放的逻辑与 First-Fit 相同，核心在于**合并相邻空闲块**。函数首先将归还的内存块标记为新的空闲块，并根据其物理地址，将其插入到 `free_list` 的正确位置，以维持链表的地址有序性。检查新插入块在链表中的**前一个**空闲块，通过指针运算 (`p + p->property == base`) 判断两者在物理上是否紧邻。如果紧邻，则将两者合并成一个更大的块（更新前一地址块的 `property`），并从链表中删除当前块。同理，检查链表中的**后一个**空闲块，如果物理地址连续，也进行合并。

---

### 问题回答：

- **你的 Best-Fit 算法是否有进一步的改进空间？**

是的，它自身有一些缺陷还可以进行进一步的改进

### 一. 主要缺陷：

 **1.性能开销大**：

其最大的缺点是性能。为了找到“最佳”的块，每一次内存分配都必须**遍历整个空闲链表**，时间复杂度为 O(n)。当系统长时间运行，`free_list` 变得很长且充满碎片时，分配性能会急剧下降。并且由于总是寻找最“贴身”的块进行分配，Best-Fit 算法最容易在分割后产生大量尺寸极小、几乎无法再被利用的外部碎片。

**2.改进方向**：

**优化数据结构**：最直接的改进是放弃单一链表。我们可以维护多个空闲链表，每个链表负责一个特定的大小范围。当需要分配 `n` 页时，只需在对应大小范围的链表中寻找 Best-Fit 即可，极大地减少了需要扫描的节点数量。

或者可以使用**平衡二叉搜索树**或类似的树形结构来组织空闲块（按块大小排序）。这样，查找最佳匹配块的时间复杂度可以从 O(n) 优化到 **O(log n)**，虽然这会增加实现的复杂度和插入/删除操作的开销，但在查找密集型的场景下，性能会显著提升。

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。