# 操作系统lab1实验报告
<center><p><font face="黑体" size=7><b>操作系统lab1实验报告</b></font></p></center>
<center><p><font face="楷体" size=4>姓名：宋卓伦，赵雨萱，何立烽&nbsp;&nbsp;&nbsp;&nbsp;学号：2311095，2311100，2311101</font></p></center>
<center><p><font face="楷体" size=4>南开大学计算机学院、密码与网络空间安全学院</font></p></center>
<!-- <br> -->

## 实验名称：物理内存管理

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

---

### 各函数作用及物理内存分配过程分析

程序通过 `default_pmm_manager` 结构体，利用函数指针将具体的内存管理算法（First-Fit）封装起来。物理内存的分配和释放过程主要围绕一个按地址排序的空闲块双向链表 `free_list` 展开。

**各核心函数作用分析如下：**

* **`default_init()`**
    * **作用**: 初始化内存管理器。
    * **描述**: 这是系统启动时调用的第一个函数。它通过调用 `list_init(&free_list)` 创建一个空的双向链表，然后将全局空闲页总数 `nr_free` 设置为0。在这一阶段，内核还不知道具体有哪些物理内存是可用的。

* **`default_init_memmap()`**
    * **作用**: 将一块新发现的、可用的物理内存区域，格式化后加入到空闲链表中。
    * **描述**: 函数接收一个指向 `Page` 结构体的指针 `base` 和连续页的数量 `n`。它首先遍历这 `n` 个页，清除它们的 `flags` 标志位并将引用计数 `ref` 置为0。接着，它将起始页 `base` 的 `property` 字段设置为 `n`，并调用 `SetPageProperty(base)`，以此明确标记这是一个大小为 `n` 的空闲块的“头部”。最后，将 `n` 加到 `nr_free` 上，并通过一个 `while` 循环找到正确的位置，将这个新的空闲块插入到 `free_list` 中，确保整个链表始终按照物理地址从小到大排序。

* **`default_alloc_pages()`**
    * **作用**: 实现 First-Fit 算法的核心，负责查找并分配 `n` 个连续的物理页。
    * **描述**:
        1.  **检查**: 首先进行合法性检查，确保 `n > 0` 且总空闲页数 `nr_free` 足够，否则返回 `NULL`。
        2.  **查找**: 从 `free_list` 的头部开始遍历，寻找**第一个** `property >= n` 的空闲块。一旦找到，立刻用 `break` 停止搜索。
        3.  **分割**: 如果找到的块 `page` 比请求的 `n` 大 (`page->property > n`)，则进行分割。将 `page` 从 `free_list` 中移除，然后计算出剩余部分（从 `page + n` 开始），将其大小（`page->property - n`）记录在新头部，并作为一个新的小空闲块重新插入 `free_list`。
        4.  **更新**: 从 `nr_free` 中减去 `n`，调用 `ClearPageProperty(page)` 清除已分配块的“空闲头部”标志。
        5.  **返回**: 返回指向已分配内存块头部的指针 `page`。

* **`default_free_pages()`**
    * **作用**: 将一块使用完毕的内存归还给系统，并尝试与相邻的空闲块合并。
    * **描述**:
        1.  **标记**: 函数接收要释放的内存块 `base` 和大小 `n`，重置其内部所有页的标志位和引用计数。然后将其标记为一个新的、大小为 `n` 的空闲块。
        2.  **插入**: 将这个新释放的块按地址顺序插入到 `free_list` 中。
        3.  **合并**: 这是防止内存碎片化的关键。它会检查新插入块在链表中的**前一个**和**后一个**空闲块，判断它们在物理地址上是否紧邻。如果紧邻，就将它们合并成一个更大的空闲块，更新 `property` 值，并从链表中删除被“吃掉”的那个块。

* **`default_nr_free_pages()`**
    * **作用**: 查询当前空闲页的总数。
    * **描述**: 直接返回全局变量 `nr_free` 的值。

* **`default_check()`**
    * **作用**: 内置的自检程序，用于验证内存管理算法的正确性。
    * **描述**: 通过一系列预设的分配和释放操作，以及 `assert` 断言，来测试分配、释放、分割和合并等核心逻辑是否按预期工作。

---

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。