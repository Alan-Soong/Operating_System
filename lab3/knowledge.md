## 1.中断前后需要恢复上下文环境，用一个名为中断帧（TrapFrame）的结构体存储了要保存的各寄存器.    
## 2.内核初始化函数kern_init()的执行流：  
(从kern/init/entry.S进入)   
```
addi t0, t0, %lo(kern_init)  
jr t0
```
-> 输出一些信息说明正在初始化   
-> 设置中断向量表(stvec)跳转到的地方为kern/trap/trapentry.S里的一个标记    
```
extern void __alltraps(void);  
.globl __alltraps
```
->在kern/driver/clock.c设置第一个时钟事件，使能时钟中断   
```
clock_init(); 
   clock_set_next_event();
```
->设置全局的S mode中断使能位  
```
void intr_enable(void) { set_csr(sstatus, SSTATUS_SIE); }
//在init.c
```
-> 现在开始不断地触发时钟中断  
## 3.产生一次时钟中断的执行流：  
**这里很可能是sbi_set_timer()** set_sbi_timer()通过OpenSBI的时钟事件触发一个中断，跳转到kern/trap/trapentry.S的__alltraps标记   
```
/ 1. 启用时钟中断使能
set_csr(sie, MIP_STIP);  // 设置 sie.STIP = 1,允许 Supervisor 模式接收时钟中断

// 2. 设置定时器
sbi_set_timer(get_cycles() + timebase);

// 3. 当定时器到期时，OpenSBI 会：
//    - 设置 sip.STIP = 1  （标记时钟中断待处理）

// 4. CPU 检查中断条件：
//    - sip.STIP == 1?    （有定时器中断待处理）
//    - sie.STIP == 1?    （定时器中断已使能）  
//    - sstatus.SIE == 1? （全局中断已使能）
//    如果都满足，则触发中断
// 5. CPU 会自动：
      - 保存上下文到相关CSR
      - 跳转到 stvec 寄存器指向的地址（即 __alltraps）
      write_csr(stvec, &__alltraps); 
      //在trap.c里面配置stvec寄存器为__alltraps
```

| 寄存器 | 全称                         | 作用                             |
| :----- | :--------------------------- | :------------------------------- |
| sie    | Supervisor Interrupt Enable  | 控制哪些中断可以被响应（使能）   |
| sip    | Supervisor Interrupt Pending | 记录哪些中断正在等待处理（挂起） |

三个条件缺一不可的原因：

- sip.STIP=1：确保确实有中断事件发生

- sie.STIP=1：确保操作系统愿意处理这类中断

- sstatus.SIE=1：确保当前时刻适合处理中断

-> 保存当前执行流的上下文，并通过函数调用，切换为kern/trap/trap.c的中断处理函数trap()的上下文，进入trap()的执行流。切换前的上下文作为一个结构体，传递给trap()作为函数参数   
-> kern/trap/trap.c按照中断类型进行分发(trap_dispatch(), interrupt_handler())  
->执行时钟中断对应的处理语句，累加计数器，设置下一次时钟中断  
->完成处理，返回到kern/trap/trapentry.S  
->恢复原先的上下文，中断处理结束。
## 4.中断机制需要软件硬件一起来支持。硬件进行中断和异常的发现，然后交给软件来进行处理。
## 5.中断或异常可以发生在处理器执行时的任何特权级  
一个发生在特定特权级的事件，最终会由哪个特权级的代码来处理？答案并非一成不变，而是由RISC-V灵活的中断委托机制与系统软件的设计共同决定的。  
默认情况下，RISC-V遵循最保守的安全设计：**所有中断与异常都会首先陷入最高特权级—— M 模式。**（但会带来不必要的性能开销和灵活性限制。）  
RISC-V引入了**中断委托机制**。M模式可以通过设置两个关键寄存器，将特定的中断与异常处理权"下放"给S模式，在ucore启动时，OpenSBI固件会进行初始化，将绝大部分S模式与U模式相关的中断和异常委托出去。
## 6.CSR 是 Control and Status Register（控制与状态寄存器）  
stvec(Supervisor Trap Vector Base Address Register)，即所谓的**中断向量表基址**。中断向量表的作用就是把不同种类的中断**映射**到对应的中断处理程序。如果只有一个中断处理程序，那么可以让stvec直接指向那个中断处理程序的地址。  
stvec会把最低位的两个二进制位用来编码一个"模式"，62个二进制位编码一个64位的地址，RISCV架构要求这个地址是四字节对齐的，总是在较高的62位后补两个0。
## 7.硬件记录上下文
关键点3个寄存器（sepc、scause、stval）  
除了sstatus寄存器中的SIE控制位，还存在一个sie寄存器，即使 sstatus.SIE 为 1，也可以通过 sie 寄存器屏蔽特定类型的中断。
## 8.流程
这些事件都触发了相关处理流程，将程序的运行状态从 U 模式转入 S 模式。

首先，保存中断发生时的pc值，即程序计数器的值，这个值会被保存在sepc寄存器中。对于异常来说，这通常是触发异常的指令地址，而对于中断来说，则是被打断的指令地址。然后，记录中断或异常的类型，并将其写入scause寄存器。这里的scause会告诉系统是中断还是异常，且会给出具体的中断类型。

接下来，保存相关的辅助信息。如果异常与缺页或访问错误相关，将相关的地址或数据保存到stval寄存器，以便中断处理程序在后续处理中使用。紧接着，保存并修改中断使能状态。将当前的中断使能状态sstatus.SIE保存到sstatus.SPIE中，并且会将sstatus.SIE清零，从而禁用 S 模式下的中断。这是为了保证在处理中断时不会被其他中断打断。

然后，保存当前的特权级信息。将当前特权级（即 U 模式，值为 0）保存到sstatus.SPP中，并将当前特权级切换到 S 模式。此时，系统已经进入 S 模式，准备跳转到中断处理程序。将pc设置为stvec寄存器中的值，并跳转到中断处理程序的入口。（需要初始化stvec寄存器。我们采用Direct模式，也就是stvec直接指向唯一的中断处理程序入口点，所有类型的中断和异常都会跳转到这里。）    

利用C语言里面的结构体（保存上下文），是若干个变量在内存里直线排列。也就是说，一个trapFrame结构体占据36个uintptr_t的空间（在64位RISCV架构里我们定义uintptr_t为64位无符号整数），里面依次排列通用寄存器x0到x31,然后依次排列4个和中断相关的CSR, 我们希望中断处理程序能够利用这几个CSR的数值。

首先我们定义一个汇编宏 SAVE_ALL, 用来保存所有寄存器到栈顶（实际上把一个trapFrame结构体放到了栈顶）。**RISCV不能直接从CSR写到内存, 需要csrr把CSR读取到通用寄存器，再从通用寄存器STORE到内存。**

.align(2) #中断入口点 __alltraps必须四字节对齐 **真正入口**

然后是恢复上下文的汇编宏，恢复的顺序和当时保存的顺序反过来，先加载两个CSR, 再加载通用寄存器。  
sstatus.SPP设置为 0，表示要返回到 U 模式，执行sret指令，根据sstatus.SPP的值（此时为 0）切换回 U 模式。

## 9.特权级用户级保存在哪个寄存器里？

## 10.时钟中断  
每秒100次时钟中断，触发每次时钟中断后设置10ms后触发下一次时钟中断，每触发100次时钟中断（1秒钟）输出一行信息到控制台。  
设置时钟中断间隔设置为CPU频率的1%  
rdtime伪指令，读取一个叫做time的CSR的数值，表示CPU启动之后经过的真实时间。在不同硬件平台，时钟频率可能不同。在QEMU上，这个时钟的频率是10MHz, 每过1s, rdtime返回的结果增大10000000  
对于QEMU, timer增加1，过去了10^-7 s， 也就是100ns

## 11.断亦有断

do { ... } while(0) 是 C 语言中宏定义的常用技巧，其核心目的是保证宏的语法正确性和使用灵活性，尤其在宏包含多条语句或可能在复杂语法结构中使用时不可或缺。