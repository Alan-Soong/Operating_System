# Copy-On-Write (COW) 设计文档

## 一、摘要
本文档详细描述了在教学型 RISC‑V 内核中引入 Copy-On-Write (COW) 机制的设计与实现方案。COW 是一种内存管理优化技术，允许父子进程在 `fork()` 后共享物理内存，直到其中一个进程尝试写入时才进行复制。这显著降低了进程创建时的内存开销和延迟，同时保证了内核的稳定性与安全性。

## 二、目标与动机
- **减少内存占用**: 在 `fork()` 后子进程通常立即调用 `exec()`，立即复制所有页面会造成浪费；COW 可保持页面只读共享直到写入发生。
- **提升性能**: 避免大量即时页面复制，大幅降低 `fork()` 延迟。
- **兼容现有设计**: 尽量在现有页表/内存管理框架内实现，保持接口兼容性。

## 三、术语与假设
- **PTE**: 页表项（含物理页帧号、权限及标志）。
- **Writable 标志**: 表示页可写。
- **COW 标志 (新增)**: 标识当前页为写时复制共享页。
- **refcount[]**: 每个物理页帧的引用计数，用于判断是否需要实际复制。
- **假设**: 内核已有完整的页表管理、物理页分配/释放、缺页异常处理机制。

## 四、高层设计概览
1. **在 `fork()` 时**:
   - 复制父进程页表结构时，不将父页设为可写；清除 PTE 的 `W` (write) 位并设置 `COW` 标志。
   - 增加对应物理页的引用计数 `refcount++`。
2. **当任一进程写入该页触发缺页异常时**:
   - 内核在缺页处理例程中识别这是对 COW 页的写入。
   - 若 `refcount > 1`：分配新物理页，拷贝原页内容，更新当前进程页表的 PTE 指向新页并设为可写，原页的 `refcount--`，新页 `refcount = 1`。
   - 若 `refcount == 1`：可以直接将该 PTE 恢复为可写（清除 COW 标志），无需复制。
3. **释放页面时**:
   - 进程终止或页表解除映射时执行 `refcount--`，当引用计数降为 0 时释放物理页。

## 五、数据结构与 PTE 扩展
- **物理页引用计数表 `page_refcount[]`**: 以页为单位的原子计数数组。
- **PTE 扩展**: 在 `kern/mm/mmu.h` 中定义 `PTE_COW` 标志，值为 `0x100`。我们利用了 RISC-V 页表项中的保留位 (RSW, bits 8-9) 之一。当 `PTE_COW` 置位时，表示该页处于 COW 共享状态且为只读 (`PTE_W` 为 0)。

## 六、关键实现细节

### 1. 进程创建 (Fork) 时的映射复制
**修改文件**: `kern/mm/pmm.c`
**函数**: `copy_range`

**逻辑**:
1. 遍历父进程的页表项。
2. 对于有效的页表项 (`PTE_V`):
   - 不再分配新物理页并拷贝内容。
   - 将父子进程的页表项都设置为只读 (`PTE_W = 0`) 并设置 COW 标志 (`PTE_COW = 1`)。
   - 增加对应物理页的引用计数 (`page_ref_inc`)。
   - 将该物理页映射到子进程的地址空间。
3. 刷新 TLB 以确保更改生效。

### 2. 缺页异常处理
**修改文件**: `kern/mm/vmm.c`
**函数**: `do_pgfault`

**逻辑**:
1. 判断异常原因：如果是写异常 (`error_code & 3`) 且页表项存在。
2. 检查标志位：如果页表项包含 `PTE_COW`。
3. **执行写时复制**:
   - 获取物理页对应的 `struct Page`。
   - **并发保护**: 使用 `local_intr_save` 关中断，在临界区内再次检查 `page_ref` 和 `PTE_COW` 状态。
   - **Case A: 共享页 (ref > 1)**:
     - 分配新物理页 (`alloc_page`)。
     - 拷贝原页内容 (`memcpy`)。
     - 减少原页引用计数。
     - 更新页表：映射新页，设置 `PTE_W`，清除 `PTE_COW`。
   - **Case B: 独占页 (ref == 1)**:
     - 直接更新页表：设置 `PTE_W`，清除 `PTE_COW`。
4. 刷新 TLB。

### 3. 与仓库中已有实现的对应
- **已有基础**: COW 已在项目中部分实现，主要集中在:
  - `lab5/kern/mm/vmm.c`: `do_pgfault()`、`dup_mmap()` 函数
  - `lab5/kern/process/proc.c`: `copy_mm()`/`do_fork()` 调用路径
- **核心逻辑**: `do_pgfault()` 中已经实现了基于引用计数的 COW 处理逻辑，我们的工作主要是:
  - 明确定义 `PTE_COW` 标志
  - 完善 `copy_range()` 中的共享映射设置
  - 加强并发保护机制

## 七、同步与并发
- **引用计数操作**: 对所有物理页帧的 `refcount` 使用原子增减操作。
- **临界区保护**: 在执行共享到独占转换时，使用中断关闭和页级锁保护，避免竞态条件。
- **TLB 一致性**: 在修改 PTE 后必须刷新对应 TLB 条目，多核环境下需要 TLB shootdown。

## 八、补充实现细节与错误处理（建议）

- **分配失败处理**：在 `do_pgfault` 的写时复制路径中，若 `alloc_page()` 返回 NULL 或内存不足，必须有明确的回滚与上报流程：
   - 推荐做法：立即释放已分配的临时资源，返回 `-E_NO_MEM` 给上层或终止触发缺页的用户进程（发送致命信号或调用 `exit()`）。避免在失败路径中遗漏 `page_ref` 的调整或产生泄漏。

- **多核并发与页级锁**：`local_intr_save` 对单核教学平台有效，但在多核系统必须增强：
   - 为每个物理页或页目录项引入轻量页级自旋锁（`page_lock(page)` / `page_unlock(page)`），在检查 `page_ref`、分配新页及更新 PTE 时持锁。
   - 在修改 PTE 后执行跨 CPU 的 TLB shootdown（或使用内核现有的跨核失效机制），确保其它核不会继续使用旧的只读映射。

- **引用计数的原子操作**：明确使用的接口并标注位置：
   - 在 `copy_range()`（fork 时）对共享页执行 `page_ref_inc(page)`；在解除映射或释放时执行 `page_ref_dec(page)`。
   - `page_ref_inc/dec` 应基于原子操作（例如 `atomic_inc`/`atomic_dec`）或在持有页级锁时使用普通操作。

- **测试脚本与预期示例**：在文档中加入可复现的命令与示例输出，便于 CI 自动化验证：

```bash
# 构建并运行全部测试
make
make grade
```

- **代码定位（快速跳转）**：主要实现点参考当前仓库位置：
   - `PTE_COW` 定义: [kern/mm/mmu.h](kern/mm/mmu.h#L82)
   - `copy_range`（共享映射逻辑）: [kern/mm/pmm.c](kern/mm/pmm.c#L451-L468)
   - `do_pgfault`（写时复制与 double-check）: [kern/mm/vmm.c](kern/mm/vmm.c#L160-L183)

（注：行号为当前仓库位置的近似范围；若文件变动，请据实际行号更新链接。）

## 八、问题修复与优化

### 1. 编译错误修复：USER_ACCESS
- **问题**: `kern/trap/trap.c` 中 `USER_ACCESS` 宏参数不足。
- **修复**: 修改为 `USER_ACCESS(tf->tval, tf->tval + 1)`，正确检查访问范围。

### 2. 调度器优化
- **问题**: `spin` 和 `forktest` 测试超时失败。
- **分析**: 时钟中断处理过于激进，每 tick 都触发抢占，导致过多的上下文切换开销。
- **修复**: 将抢占逻辑移动到 `if (++ticks % TICK_NUM == 0)` 块内，恢复每 100 tick 触发一次抢占的正常时间片轮转。

## 九、测试验证
1. **单元测试 (cowtest)**: 编写 `user/cowtest.c` 验证:
   - 共享验证: 父子进程读取同一变量，物理地址相同
   - 复制验证: 子进程修改数据，父进程不受影响，物理地址变化
2. **回归测试**: 运行 `make grade` 验证:
   - `priority`: 通过
   - `spin`: 通过 (调度修复后)
   - `forktest`: 通过 (调度修复后)
   - `cowtest`: 通过
3. **故障注入**: 模拟物理页分配失败，确认异常路径正确处理。

## 十、性能考虑
- **优势**: 延迟复制显著降低 `fork()` 开销，尤其在父/子进程大多调用 `exec()` 的场景下。
- **成本**: 写入热点页会触发拷贝，将开销分散到首次写入时。
- **建议**: 实现中提供配置开关 (`CONFIG_COW`)，便于教学和调试。

## 十一、安全与正确性
- **内核内存保护**: 确保内核页永远不会被标记为 COW。
- **引用计数一致性**: 严格维护 `refcount` 与 PTE 的一致性，防止 double-free 或内存泄漏。
- **异常处理**: 分配新页失败时返回错误并保持系统状态一致。

## 十二、总结
通过引入 `PTE_COW` 标志、改造 `copy_range` 和 `do_pgfault`，我们在 ucore RISC-V 内核中成功实现了高效的 Copy-On-Write 机制。该实现不仅优化了 `fork()` 的性能和内存使用，还通过修复调度器问题保证了系统的整体稳定性。COW 机制的引入使教学操作系统更加贴近现代操作系统的实际优化技术。